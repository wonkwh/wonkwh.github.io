<!DOCTYPE html>
<html lang="en">
    <head>
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <meta http-equiv="content-type" content="text/html; charset=utf-8">

      <!-- Enable responsiveness on mobile devices-->
      <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

      <title></title>

      

      
          <link rel="stylesheet" href="https://wonkwh.github.io/site.css">
      

      
      
    </head>

    <body class="hack dark main container">
        

<article itemscope itemtype="http://schema.org/BlogPosting">
    <header>
        <h1 itemprop="headline">Refactoring Massive App Delegate</h1>
        <span class="muted">
    <svg style="margin-bottom:-3px" class="i-clock" viewBox="0 0 32 32"
         width="16" height="16" fill="none" stroke="currentcolor"
         stroke-linecap="round" stroke-linejoin="round" stroke-width="6.25%">
        <circle cx="16" cy="16" r="14"/>
        <path d="M16 8 L16 16 20 20"/>
    </svg>
    <span>3 minute read</span>
    <svg style="margin-bottom: -3px" class="i-edit" viewBox="0 0 32 32"
         width="16" height="16" fill="none" stroke="currentcolor"
         stroke-linecap="round" stroke-linejoin="round" stroke-width="6.25%">
        <path d="M30 7 L25 2 5 22 3 29 10 27 Z M21 6 L26 11 Z M5 22 L10 27 Z"/>
    </svg>

    Published: 2021-02-01
</span>
    </header>
    <div itemprop="articleBody">
      <h2 id="refactoring-massive-app-delegate">Refactoring Massive App Delegate</h2>
<p>실제 production app 을 개발하다 보면 <code>AppDelegate</code> 클래스가 쉽게 비대해지고 파일수가 어마어마하게 늘어나는 경우가 비일비재하다. 이를 refactoring 하는 방법</p>
<span id="continue-reading"></span><h3 id="mediator-design-pattern">Mediator Design Pattern</h3>
<p><a href="https://www.vadimbulavin.com/refactoring-massive-app-delegate/">refactoring-massive-app-delegate</a> 에 보면 다양한 디자인 패턴으로 appDelegate를 refactoring 하는 법이 나와있다 그중 mediator design pattern 으로 실제 활용한 예</p>
<h3 id="applifecycle-mediator">AppLifecycle Mediator</h3>
<ul>
<li>먼저 AppLifeCycle mediator 를 정의한다.</li>
<li>아래 소스는 <code>appDelegate.m</code> 이 objective-c 로 구현되어 있기에 <code>NSObject</code>를 상속받고 <code>objc</code> propertyObserver를 붙였다.</li>
</ul>
<pre data-lang="swift" class="language-swift "><code class="language-swift" data-lang="swift">import Foundation

&#x2F;&#x2F; MARK: - AppLifecycleListener
protocol AppLifecycleListener {
  func onAppWillEnterForeground()
  func onAppDidEnterBackground()
  func onAppDidFinishLaunching()
}

extension AppLifecycleListener {
  func onAppWillEnterForeground() {}
  func onAppDidEnterBackground() {}
}

&#x2F;&#x2F; MARK: - Mediator
@objc
class AppLifecycleMediator: NSObject {
  private let listeners: [AppLifecycleListener]
  
  init(listeners: [AppLifecycleListener]) {
    self.listeners = listeners
    super.init()
    subscribe()
  }
  
  deinit {
    NotificationCenter.default.removeObserver(self)
  }
  
  private func subscribe() {
    NotificationCenter.default.addObserver(self, selector: #selector(onAppWillEnterForeground), name: UIApplication.willEnterForegroundNotification, object: nil)
    NotificationCenter.default.addObserver(self, selector: #selector(onAppDidEnterBackground), name: UIApplication.didEnterBackgroundNotification, object: nil)
    NotificationCenter.default.addObserver(self, selector: #selector(onAppDidFinishLaunching), name: UIApplication.didFinishLaunchingNotification, object: nil)
  }
  
  @objc private func onAppWillEnterForeground() {
    listeners.forEach { $0.onAppWillEnterForeground() }
  }
  
  @objc private func onAppDidEnterBackground() {
    listeners.forEach { $0.onAppDidEnterBackground() }
  }
  
  @objc private func onAppDidFinishLaunching() {
    listeners.forEach { $0.onAppDidFinishLaunching() }
  }
}
</code></pre>
<h3 id="applistener-class-guhyeon">AppListener class 구현</h3>
<ul>
<li>이제 <code>AppLifecycleListener</code> 를 상속하여 클래스를 구현한다.</li>
<li>appDelegate 에서 구현된 각각의 서비스 구현들을 여기에 Extract 하여 구현</li>
<li>예를 들면 기존에 AppDelegate에서 구현되어있던 location permission 관련 feature 들은 아래와 같이 <code>AppLocationListener</code> 구현한다.</li>
</ul>
<pre data-lang="swift" class="language-swift "><code class="language-swift" data-lang="swift">import Foundation
import CoreLocation
import LoggingKit

class AppLocationListener: NSObject, AppLifecycleListener {
 let locationManager = CLLocationManager()
 
 fileprivate func permissionState(_ status: CLAuthorizationStatus) {
   LogService.shared.debug(&quot;LocationPermission: \(status.rawValue)&quot;, logCategory: \.debug)
   switch status {
   case .authorizedAlways, .authorizedWhenInUse:
     locationManager.startUpdatingLocation()
   case .restricted, .notDetermined:
     locationManager.requestWhenInUseAuthorization()
   case .denied:
     stopLocation()
   @unknown default:
     print(&quot;GPS: Default&quot;)
   }
 }
 
 func stopLocation() {
   locationManager.stopUpdatingHeading()
   locationManager.stopUpdatingLocation()
   locationManager.delegate = nil
 }
 
 func onAppDidFinishLaunching() {
   locationManager.delegate = self
   locationManager.desiredAccuracy = kCLLocationAccuracyBest
   let status: CLAuthorizationStatus
   if #available(iOS 14.0, *) {
     status = locationManager.authorizationStatus
   } else {
     status = CLLocationManager.authorizationStatus()
   }
   permissionState(status)
 }
}

extension AppLocationListener: CLLocationManagerDelegate {
 func locationManager(_ manager: CLLocationManager, didChangeAuthorization status: CLAuthorizationStatus) {
   self.permissionState(status)
 }
 
 func locationManager(_ manager: CLLocationManager, didFailWithError error: Error) {
   locationManager.stopUpdatingLocation()
 }
 
 func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) {
   let newLocation = locations[0]
   let geocoder = CLGeocoder()
   geocoder.reverseGeocodeLocation(newLocation) { (playmarks, error) in
     if let _ = error {
       self.stopLocation()
       return
     }
     
     if let city = playmarks?.first?.locality {
       cityDefault.saveLocationLng(&quot;\(newLocation.coordinate.longitude)&quot;)
       cityDefault.saveLocationLat(&quot;\(newLocation.coordinate.latitude)&quot;)
       cityDefault.saveLocationCity(city)
     }
   }
   stopLocation()
 }
}

</code></pre>
<ul>
<li>그리고 <code>AppLifecycleMediator</code> 에 listener  에 추가</li>
</ul>
<pre data-lang="swift" class="language-swift "><code class="language-swift" data-lang="swift">extension AppLifecycleMediator {
  @objc
  static func makeDefaultMediator() -&gt; AppLifecycleMediator {
    let locationListener = AppLocationListener()
    let debugListener = AppDebugListener()

    return AppLifecycleMediator(listeners: [debugListener, locationListener])
  }
}

</code></pre>
<ul>
<li>3rdParty service 들, debug feature 등 listener 로 추가하여 refactoring 해주면 된다. </li>
</ul>
<h3 id="add-mediator-to-appdelegate">add mediator to AppDelegate</h3>
<ul>
<li>이제 mediator class 를 AppDelegate 에 등록한다.</li>
<li>다음 코드 한줄만 appDelegate 에 추가하면 된다.</li>
</ul>
<pre data-lang="swift" class="language-swift "><code class="language-swift" data-lang="swift">@UIApplicationMain

class AppDelegate: UIResponder, UIApplicationDelegate {

   var window: UIWindow?

   let mediator = AppLifecycleMediator.makeDefaultMediator() &#x2F;&#x2F; 여기에 추가

   func application(_ application: UIApplication,                                           didFinishLaunchingWithOptions launchOptions:                              [UIApplicationLaunchOptionsKey: Any]?) -&gt; Bool {

      return true

   }
}
</code></pre>
<ul>
<li>objective-c 구현에 붙인다면 조금 애매한데 <code>willFinishLaunchingWithOptions</code> 메소드에 다음과 같이 추가하였다. </li>
</ul>
<pre data-lang="objc" class="language-objc "><code class="language-objc" data-lang="objc">@interface AppDelegate ()&lt;CLLocationManagerDelegate, UNUserNotificationCenterDelegate, FIRMessagingDelegate, AppsFlyerLibDelegate&gt;
{
  AppLifecycleMediator *_mediator; &#x2F;&#x2F; 여기에 선언하고 
}


...
- (BOOL)application:(UIApplication *)application willFinishLaunchingWithOptions:(NSDictionary *)launchOptions {
  _mediator = [AppLifecycleMediator makeDefaultMediator]; &#x2F;&#x2F; 구현추가.
  return YES;
}

</code></pre>
<h2 id="reference">Reference</h2>
<ul>
<li><a href="https://www.vadimbulavin.com/refactoring-massive-app-delegate/">refactoring-massive-app-delegate</a></li>
<li><a href="https://andreaslydemann.com/architecting-an-analytics-service-for-ios-apps/">Architecting an Analytics Service for iOS Apps – Andreas Lüdemann (andreaslydemann.com)</a></li>
</ul>

    </div>

    
        <footer>
            <hr>
            <p>
                
                    Published by Kwanghyun Won
                
                
                
                    and tagged
                    
                        <a href="https://wonkwh.github.io/tags/swift/">swift</a>
                        
                            
                                
                                    ,
                                
                            
                        
                    
                        <a href="https://wonkwh.github.io/tags/appdelegate/">appdelegate</a>
                        
                            
                                
                                    ,
                                
                            
                        
                    
                        <a href="https://wonkwh.github.io/tags/design-pattern/">design_pattern</a>
                        
                            
                                
                                    and
                                
                            
                        
                    
                        <a href="https://wonkwh.github.io/tags/refactoring/">refactoring</a>
                        
                            
                        
                    
                
            </p>
        </footer>
    
</article>


    </body>

</html>
