<!DOCTYPE html>
<html lang="en">
    <head>
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <meta http-equiv="content-type" content="text/html; charset=utf-8">

      <!-- Enable responsiveness on mobile devices-->
      <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

      <title></title>

      

      
          <link rel="stylesheet" href="https://wonkwh.github.io/site.css">
      

      
      
    </head>

    <body class="hack dark main container">
        

<article itemscope itemtype="http://schema.org/BlogPosting">
    <header>
        <h1 itemprop="headline">Swinject Tutorial for iOS</h1>
        <span class="muted">
    <svg style="margin-bottom:-3px" class="i-clock" viewBox="0 0 32 32"
         width="16" height="16" fill="none" stroke="currentcolor"
         stroke-linecap="round" stroke-linejoin="round" stroke-width="6.25%">
        <circle cx="16" cy="16" r="14"/>
        <path d="M16 8 L16 16 20 20"/>
    </svg>
    <span>5 minute read</span>
    <svg style="margin-bottom: -3px" class="i-edit" viewBox="0 0 32 32"
         width="16" height="16" fill="none" stroke="currentcolor"
         stroke-linecap="round" stroke-linejoin="round" stroke-width="6.25%">
        <path d="M30 7 L25 2 5 22 3 29 10 27 Z M21 6 L26 11 Z M5 22 L10 27 Z"/>
    </svg>

    Published: 2024-02-22
</span>
    </header>
    <div itemprop="articleBody">
      <ul>
<li>원문: https://www.kodeco.com/17-swinject-tutorial-for-ios-getting-started</li>
<li>이 튜토리얼에서는 Swift로 작성된 의존성 주입 프레임워크인 Swinject를 통해 의존성 주입(DI)의 개념에 대해 알아본다</li>
</ul>
<span id="continue-reading"></span>
<ul>
<li>비트코인의 현재 가격을 표시하는 <a href="https://github.com/wonkwh/BlogShowcase/tree/develop/BitcoinAdventurer">BitcoinAdventure</a> 라는 작은 iOS 애플리케이션을 개선하는 방식으로 진행</li>
<li>튜토리얼을 진행하면서 앱을 리팩터링하고 그 과정에서 단위 테스트를 추가.</li>
</ul>
<h2 id="dependancy-injection">Dependancy Injection</h2>
<ul>
<li>종속성 주입 (Dependancy Injection) 은 코드 자체 대신 다른 객체에서 종속성을 제공하도록 코드를 구성하는 접근 방식..</li>
<li>이렇게 코드를 정리하면 테스트 및 리팩토링할 수 있는 느슨하게 결합된(loosely-coupled) 구성 요소로 구성된 코드베이스가 생성.</li>
<li>타사 라이브러리 없이도 의존성 주입을 구현할 수 있지만, 널리 사용되는 패턴인 의존성 주입(DI) 컨테이너 (DI Container) 를 사용 하는 Swinject 를 사용</li>
<li>이러한 유형의 패턴은 코드 복잡성이 증가하더라도 종속성 해결을 단순하게 유지합니다.</li>
</ul>
<h2 id="jongsogseong-juibi-pilyohan-iyu">종속성 주입이 필요한 이유</h2>
<ul>
<li>의존성 주입은 제어의 역전(<strong>Inversion of Control</strong>) 이라는 원칙에 의존.</li>
<li>주요 개념은 일부 종속성이 필요한 코드가 자체적으로 종속성을 생성하지 않고 이러한 종속성을 제공하는 제어를 더 높은 추상화로 위임</li>
<li>이러한 종속성은 일반적으로 객체의 이니셜라이저로 전달</li>
<li>이는 일반적인 계단식 객체 생성의 반대되는 접근 방식, 즉 반전된 접근 방식</li>
<li>객체 A가 객체 B를 생성하고, 객체 C를 생성하는 식</li>
<li>실용적인 관점에서 볼 때, 제어 반전의 주요 이점은 코드 변경이 격리된 상태로 유지</li>
<li>의존성 주입 컨테이너는 객체에 대한 종속성을 제공하는 방법을 알고 있는 객체를 제공함으로써 제어의 역전 원칙을 지원</li>
<li>컨테이너에 필요한 객체를 요청하기만 하면 됨</li>
</ul>
<h2 id="sijaghagi">시작하기</h2>
<ul>
<li>앱이 실행되면 화면에 비트코인의 현재 가격이 표시</li>
<li>새로 고침을 탭하면 최신 데이터를 검색하기 위해 HTTP 요청</li>
<li>코인베이스 API는 약 30초마다 새로운 비트코인 가격을 제공.</li>
<li>현재 오류 가 발생
<ul>
<li><em>Swinject: Resolution failed. Expected registration:</em></li>
</ul>
</li>
<li>모든 네트워킹 및 구문 분석 로직은 <code>BitcoinViewController.swift</code></li>
<li>현재 코드 상태로는 뷰 레이어가 기본 로직 및 종속성과 매우 밀접하게 연결</li>
<li>UIViewController 수명 주기와 독립적으로 로직을 테스트하기 어렵다</li>
</ul>
<h2 id="diwa-keopeulring">DI와 커플링</h2>
<ul>
<li><code>BitcoinViewController.swift</code> 의 코드는 크게 세 가지를 담당
<ul>
<li>Networking, Parsing, Formatting</li>
</ul>
</li>
</ul>
<h3 id="networking-and-parsing">Networking and Parsing</h3>
<ul>
<li>대부분 network는 다음메소드에서 발생</li>
</ul>
<pre data-lang="swift" class="language-swift "><code class="language-swift" data-lang="swift">  private func requestPrice()  {
    let bitcoin = Coinbase.bitcoin.path
    
    &#x2F;&#x2F; 1. Make URL request
    guard let url = URL(string: bitcoin) else { return }
    var request = URLRequest(url: url)
    request.cachePolicy = .reloadIgnoringCacheData
    
    &#x2F;&#x2F; 2. Make networking request
    let task = URLSession.shared.dataTask(with: request) { data, _, error in
      
      &#x2F;&#x2F; 3. Check for errors
      if let error = error {
        print(&quot;Error received requesting Bitcoin price: \(error.localizedDescription)&quot;)
        return
      }
      
      &#x2F;&#x2F; 4. Parse the returned information
      let decoder = JSONDecoder()

      guard let data = data,
            let response = try? decoder.decode(PriceResponse.self,
                                               from: data) else { return }
      
      print(&quot;Price returned: \(response.data.amount)&quot;)
      
      &#x2F;&#x2F; 5. Update the UI with the parsed PriceResponse
      DispatchQueue.main.async { [weak self] in
        self?.updateLabel(price: response.data)
      }
    }
</code></pre>
<ul>
<li>json model 은 다음과 같다.</li>
</ul>
<pre data-lang="json" class="language-json "><code class="language-json" data-lang="json">{
  &quot;data&quot;: {
    &quot;base&quot;: &quot;BTC&quot;,
    &quot;currency&quot;: &quot;USD&quot;,
    &quot;amount&quot;: &quot;15840.01&quot;
  }
}
</code></pre>
<h3 id="formatting">Formatting</h3>
<pre data-lang="swift" class="language-swift "><code class="language-swift" data-lang="swift">private func updateLabel(price: Price) {
  guard let dollars = price.components().dollars,
        let cents = price.components().cents,
        let dollarAmount = standardFormatter.number(from: dollars) else { return }
  
  primary.text = dollarsDisplayFormatter.string(from: dollarAmount)
  partial.text = &quot;.\(cents)&quot;
}
</code></pre>
<h2 id="extracting-dependencies">Extracting Dependencies</h2>
<h3 id="extracting-networking-logic">Extracting Networking Logic</h3>
<ul>
<li><code>Dependencies</code> folder 생성</li>
<li><code>HttpNetworking.swift</code>
<ul>
<li>원문 article의 소스를 swift5, result type 사용하여 수정하였다.</li>
<li>Result type 사용법은 <a href="https://www.swiftbysundell.com/basics/result/">The Result Type | Swift by Sundell</a> 요기를 참조하어 수정함.</li>
</ul>
</li>
</ul>
<pre data-lang="swift" class="language-swift "><code class="language-swift" data-lang="swift">import Foundation

enum CoinBaseError: Swift.Error {
  case networkFailure(Swift.Error)
  case invalidUrl
  case invalidData
}

public extension URLSession {
  func dataTask(
    with url: URLRequest,
    handler: @escaping (Result&lt;Data, Swift.Error&gt;) -&gt; Void
  ) -&gt; URLSessionDataTask {
    dataTask(with: url) { data, _, error in
      if let error = error {
        handler(.failure(error))
      } else {
        handler(.success(data ?? Data()))
      }
    }
  }
}

protocol Networking {
  typealias CompletionHandler = (Result&lt;Data, CoinBaseError&gt;) -&gt; Void
  func request(from: Endpoint, completion: @escaping CompletionHandler)
}

struct HTTPNetworking: Networking {
  func request(from: Endpoint, completion: @escaping CompletionHandler) {
    guard let url = URL(string: from.path) else { return }
    let request = createRequest(from: url)
    let task = createDataTask(from: request, completion: completion)
    task.resume()
  }

  private func createRequest(from url: URL) -&gt; URLRequest {
    var request = URLRequest(url: url)
    request.cachePolicy = .reloadIgnoringCacheData
    return request
  }

  private func createDataTask(
    from request: URLRequest,
    completion: @escaping CompletionHandler
  ) -&gt; URLSessionDataTask {
    return URLSession.shared.dataTask(with: request) { result in
      switch result {
      case .success(let data):
        completion(.success(data))
      case .failure(let error):
        completion(.failure(.networkFailure(error)))
      }
    }
  }
}

</code></pre>
<ul>
<li><code>BitcoinViewController.swift</code> 의 requestPrice() 을 다음과 같이 수정</li>
</ul>
<pre data-lang="swift" class="language-swift "><code class="language-swift" data-lang="swift">
  let networking = HTTPNetworking()
  ...
  
  private func requestPrice()  {
    networking.request(from: Coinbase.bitcoin) { result in
      switch result {
      case .success(let data):
        &#x2F;&#x2F; 4. Parse the returned information
        let decoder = JSONDecoder()
        guard let response = try? decoder.decode(PriceResponse.self, from: data) else { return }
        print(&quot;Price returned: \(response.data.amount)&quot;)

        &#x2F;&#x2F; 5. Update the UI with the parsed PriceResponse
        DispatchQueue.main.async { [weak self] in
          self?.updateLabel(price: response.data)
        }
      case .failure(let error):
        debugPrint(error.localizedDescription)
      }
    }
  }
</code></pre>
<h3 id="extracting-parsing-logic">Extracting Parsing Logic</h3>
<ul>
<li><code>BitcoinPriceFetcher.swift</code> 파일을 생성</li>
</ul>
<pre data-lang="swift" class="language-swift "><code class="language-swift" data-lang="swift">
import Foundation

protocol PriceFetcher {
  func fetch(response: @escaping (PriceResponse?) -&gt; Void)
}

struct BitcoinPriceFetcher: PriceFetcher {
  let networking: Networking

  &#x2F;&#x2F; 1. Initialize the fetcher with a networking object
  init(networking: Networking) {
    self.networking = networking
  }

  &#x2F;&#x2F; 2. Fetch data, returning a PriceResponse object if successful
  func fetch(response: @escaping (PriceResponse?) -&gt; Void) {
    networking.request(from: Coinbase.bitcoin) { result in
      switch result {
      case .success(let data):
        &#x2F;&#x2F; Parse data into a model object.
        let decoded = self.decodeJSON(type: PriceResponse.self, from: data)
        if let decoded = decoded {
          print(&quot;Price returned: \(decoded.data.amount)&quot;)
        }
        response(decoded)

      case .failure(let error):
        debugPrint(error.localizedDescription)
        response(nil)
      }
    }
  }

  &#x2F;&#x2F; 3. Decode JSON into an object of type &#x27;T&#x27;
  private func decodeJSON&lt;T: Decodable&gt;(type: T.Type, from: Data?) -&gt; T? {
    let decoder = JSONDecoder()
    guard let data = from,
          let response = try? decoder.decode(type.self, from: data) else { return nil }

    return response
  }
}

</code></pre>
<ul>
<li><code>BitcoinViewController.swift</code> 를 다음과 같이 수정</li>
</ul>
<pre data-lang="swift" class="language-swift "><code class="language-swift" data-lang="swift">  let fetcher = BitcoinPriceFetcher(networking: HTTPNetworking())
  ...
   private func requestPrice() {
    fetcher.fetch { response in
      guard let response = response else { return }

      DispatchQueue.main.async { [weak self] in
        self?.updateLabel(price: response.data)
      }
    }
  }
</code></pre>
<ul>
<li><code>PriveFetcher</code> protocol은  HTTP 요청이 아니더라도 모든 데이터소스에서 발생가능</li>
<li>이는 UnitTest의 중요한 특징이 될 것</li>
</ul>
<blockquote>
<p>part 1 끝
to be continue</p>
</blockquote>
<hr />
<ul>
<li>tag: #swift, #uikit, #dependancy_injection, #protocol, #design_pattern</li>
</ul>

    </div>

    
        <footer>
            <hr>
            <p>
                
                    Published by Kwanghyun Won
                
                
                
                    and tagged
                    
                        <a href="https://wonkwh.github.io/tags/swift/">swift</a>
                        
                            
                                
                                    ,
                                
                            
                        
                    
                        <a href="https://wonkwh.github.io/tags/uikit/">uikit</a>
                        
                            
                                
                                    ,
                                
                            
                        
                    
                        <a href="https://wonkwh.github.io/tags/dependancy-injection/">dependancy_injection</a>
                        
                            
                                
                                    ,
                                
                            
                        
                    
                        <a href="https://wonkwh.github.io/tags/protocol/">protocol</a>
                        
                            
                                
                                    and
                                
                            
                        
                    
                        <a href="https://wonkwh.github.io/tags/design-pattern/">design_pattern</a>
                        
                            
                        
                    
                
            </p>
        </footer>
    
</article>


    </body>

</html>
